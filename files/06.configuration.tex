\Section{Конфигурирование в компьютерных сетях}{Лекция 7}{Игорь Смирнов}

Есть два подхода к управлению сетевыми параметрами: ручная настройка и автоматизированная настройка. 

Когда мы что-то настраиваем автоматизированно, мы хотим скопом настроить несколько параметров (как минимум, IP-адрес, как максимум, ещё несколько десятков параметров).

Существует три стандартных способа автоматизированной настройки:
\begin{itemize}
    \item Протокол RARP
    \item Протокол BOOTP
    \item Протокол DHCP
\end{itemize}

\Subsection{Протоколы RARP и BOOTP}

RARP~--- совсем раритетный протокол.

Клиент без адреса обращался к серверу,а в ответ получал IP-адрес по MAC-адресу из таблицы RARP-сервера.

Использовался только для получения IP-адреса. Сейчас не используется.

BOOTP~--- долгое время был стандартом для динамического конфигурирования.

Тоже клиент-серверный подход. Есть BOOTP-сервер, который умеет по запросам раздавать необходимые параметры:
\begin{itemize}
    \item IP-адрес
    \item Маску сети
    \item Маршрутизатор <<по умолчанию>>
\end{itemize}

BOOTP позволяет иметь цепочку ретрансляторов. То есть можно иметь один сервер на несколько сегментов сети, а запросы между сегментами пересылать через ретранслятор.

Работал так же, как и RARP: администратор руками настраивал таблицу соответствия MAC-адресов и параметров узла.

BOOTP сейчас считается устаревшим.

\Subsection{Протокол DHCP}

Это чуть ли не единственный протокол, разработанный компанией Microsoft.

Цель~--- расширить количество параметров из BOOTP и расширить количество способов, как динамически управлять данными, которые запрашивают адреса.

BOOTP нас, помимо параметров, не устраивает тем, что один и тот же IP-адрес выдавался одному и тому же MAC-адресу. В DHCP этот недостаток исправлен. 

На самом деле DHCP~--- это расширение BOOTP. Но расширение настолько серьёзное, что протоколу дали навое название.

Информация размещается в поле опций протокола BOOTP.

Сервер поддерживает три режима:
\begin{itemize}
    \item Ручное распределение (то же самое, что и в BOOTP)
    \item Автоматическое распределение~--- изначально на сервере задаётся диапазон адресов, которые сервер может раздавать. По мере поступления запросов, выдаются адреса из этого диапазона. После того, как все адреса заняты, никакого отличия от ручного распределения нет: новые клиенты подключиться не могут, всем старым уже распределены адреса. Это нужно, если мы знаем, что у нас нет конкуренции за адреса и, например, хотим, чтобы у одного сотрудника компании был один и тот же адрес
    \item Динамическое распределение~--- аренда адресов. Есть пул. По запросу клиента ему в аренду (на непродолжительное время) даётся IP-адрес. Если клиент аренду не продлил, адрес снова входит в пул и его может получить другой клиент. Говорят, когда-то, много месяцев назад, до коронавируса, можно было ходить в кафе с WiFi. Так вот там как раз такое распределение. Точно так же работает распределение адресов у провайдера
\end{itemize}

Типы опций DHCP:
\begin{itemize}
    \item Базовые параметры
    \begin{itemize}
        \item Маска сети
        \item Default Gateway
        \item DNS
        \item HostName
        \item DomainName
    \end{itemize}
    \item Параметры узла
    \begin{itemize}
        \item IP forwarding (является узел маршрутизатором или нет)
        \item Default TTL
        \item ...
    \end{itemize}
    \item Параметры интерфейсов
    \begin{itemize}
        \item MTU
        \item Broadcast
        \item Static routes~--- статические маршруты, которые следует добавить. То есть через DHCP можно даже управлять маршрутизацией на отдельных узлах
    \end{itemize}
    \item Параметры TCP
    \begin{itemize}
        \item TCP Default TTL
        \item KeepAlive time
        \item ...
    \end{itemize}
    \item Параметры приложений
    \begin{itemize}
        \item NIS, NIS+~--- службы каталогов
        \item Wins
        \item POP3, SMTP, NNTP~--- почтовые серверы
        \item ...
    \end{itemize}
    \item Параметры аренды
    \begin{itemize}
        \item Запрашиваемый IP
        \item Срок аренды
        \item Идентификатор сервера
        \item ...
    \end{itemize}
    Параметрами аренды можно управлять.\\
    В Windows есть утилита {\tt ipconfig}. У неё есть параметр {\tt /renew}. Есть {\tt /release} (освободить аренду).
\end{itemize}

Сейчас DHCP~--- стандарт.

\Subsection{Управление доставкой}

Есть несколько способов доставки информации:
\begin{itemize}
    \item Маршрутизация
    \item Шлюзы уровня приложений (ALG)~--- специальное ПО, которое является посредником между получателем информации и отправителем
    \begin{itemize}
        \item Серверы посредники (прокси)
        \item Трансляции протоколов (преобразование из одного протокола в другой): стандартные трансляторы (SOCKS) и специализированные трансляторы
    \end{itemize}
    \item [Низкоуровневая] трансляция адресов (NAT)
\end{itemize} 

\Subsubsection{Серверы-посредники (proxy-серверы)}

Идея~--- использовать посредника (proxy) для получения информации из Internet.

В начале 90-х годов был интернет по подписке. По сути это реализовывалось через прокси.

Решаемые задачи:
\begin{itemize}
    \item Кэширование информации
    \item Сокрытие внутренней части сети~--- ресурс, к которому мы обращаемся, знает только о посреднике
    \item Сокращение времени доступа в сеть
\end{itemize}

Сейчас используется в основном для FTP и HTTP.

Для доступа к серверу-посреднику обычно используется HTTP. Потому что нам нужно указывать два адреса. А с url это можно без проблем сделать.

Есть стандартные порты для прокси: 3128, 8080, 8000, а иногда 80.

Ещё можно сделать иерархию кэшей (прокси идёт к следующему прокси, тот к следующему...).

Прокси на разных уровнях связаны дочерними отношениями, а прокси на одном уровне~--- родственными.

Дочерние отношения~--- как рекурсивный DNS сервер~--- если к тебе обратились за информацией, которой у тебя нет, ты сам находишь эту информацию и возвращаешь. Родственные~--- как нерекурсивный DNS сервер~--- если у тебя нет информации, ты просто сообщаешь об этом.

Казалось бы, можно построить большую систему кэшей и экономить на траффике. Но на текущий момент каналы связи такие быстрые, что найти в интернете~--- быстрее, чем облазить свою БД кэшей. Больше двух уровней использовать неэффективно.

Прокси должны синхронизировать между собой данные, какая информация у них есть. Для этого разработали протокол ICP

\Subsubsection{Протокол SOCKS}

Имел несколько версий. Используются 4 и 5.

Цель~--- обеспечить локальным неанонсированным сетям доступ к Internet.

Требует специальных SOCKS-совместимых приложений (то есть его нужно реализовывать). Но есть много реализаций ключевых протоколов

Клиент-серверное взаимодействие

SOCKS обеспечивает разграничение доступа

В SOCKS 4 есть два типа команд:
\begin{itemize}
    \item Connect (TCP)~--- запрос исходящего TCP-соединения с удалённым сервером
    \item Bind (TCP)~--- входящее TCP-соединение от какого-то сервера
\end{itemize}

То есть SOCKS двусторонний.

Транспорт TCP, порт 1080.

Отличия SOCKS 5:
\begin{itemize}
    \item Наличие аутентификации
    \item Поддержка UDP (новая команда Associate)
\end{itemize}

Telegram использует SOCKS-сервера для опосредованного доступа к заблокированным ресурсам.

\Subsubsection{Трансляция адресов NAT}

Технология сетевого уровня, которая позволяет обойти недостаток SOCKS и прокси: их надо явно прописывать в настройках.

Идея~--- <<вклиниться>> между участниками соединения.

То есть мы получаем пакет, анализируем его адрес назначения, открываем такое же соединение, подменяя его адрес на свой, а обратно данные передаём программным способом.

Недостаток: нет кеширования (потому что не знаем, что за протоколы внутри)

NAT поддерживает TCP, UDP, ICMP

NAT нельзя использовать в случаях, когда сервер, к которому мы обратились, потом что-то хочет обратно ответить клиенту (установив активное соединение). Например, так делает FTP в активном режиме.

\Subsubsection{Transparent Proxy}

Некое объединение NAT и прокси.

Ставим NAT, который анализирует, по какому номеру порта обращается пользователь. Если этот тип запроса можно кэшировать, он передаёт этот запрос прокси-серверу.

NAT и прокси могут быть на одном узле. Тут придётся пойти на то, чтобы забить на какие-то неизвестные нам порты, по которым может находиться HTTP-сервер и не кэшировать их.

\Subsection{Управление сетевыми параметрами (настройками)}

Сетевые параметры:
\begin{itemize}
    \item IP-адреса
    \item Маски интерфейсов
    \item Маршруты по умолчанию
    \item DNS-серверы
    \item WINS-серверы
    \item Proxy-серверы
    \item ...
\end{itemize}

Для контроля сетевых интерфейсов используются:
\begin{itemize}
    \item ifconfig
    \item ipconfig (Windows)
    \item netsh (Windows)
\end{itemize}

Контроль маршрутизации:
\begin{itemize}
    \item route
    \item iproute2
\end{itemize}

Контроль сетевых соединений и сокетов:
\begin{itemize}
    \item netstat
\end{itemize}

Контроль преобразования адресов:
\begin{itemize}
    \item arp
\end{itemize}

Контроль сетевой среды:
\begin{itemize}
    \item ping
    \item traceroute
\end{itemize}

Контроль и проверка DNS:
\begin{itemize}
    \item nslookup
    \item host
    \item dig
\end{itemize}

\Subsection{Анализ компьютерных сетей}

Сетевые анализаторы:
\begin{itemize}
    \item Аппаратные анализаторы (в них можно даже синтезировать трафик)
    \item Программные анализаторы (анализаторы протоколов)
    \begin{itemize}
        \item tcpdump
        \item MS Network Monitor
        \item WinDump
        \item Ethereal
        \item WireShark
        \item ...
    \end{itemize}
\end{itemize}

Анализаторы поддерживают два типа фильтрации:
\begin{itemize}
    \item Фильтр захвата (capture filters)
    \item Фильтры отображения (view filters)
\end{itemize}

Фильтрация по:
\begin{itemize}
    \item типам кадров канального уровня
    \item протоколу сетевого уровня
    \item адресам канального уровня
    \item сетевому адресу источника
    \item сетевому адресу приемника
    \item по протоколу транспортного уровня
    \item по флагам протоколов
    \item по длине пакета
\end{itemize}