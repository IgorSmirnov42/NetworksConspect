\Section{Транспортные механизмы архитектуры TCP/IP}{Лекция 3}{Игорь Смирнов}

\begin{itemize}
    \item Дейтаграммный обмен
    \begin{itemize}
        \item Не гарантирует последовательность доставки
        \item Не обеспечивает квитирование (нет сообщения о том, что пакет успешно доставлен)
        \item В TCP/IP реализуется протоколом UDP
    \end{itemize}
    \item Потоковый обмен
    \begin{itemize}
        \item Создаётся виртуальный канал (поток)
        \item Последовательность доставки гарантируется
        \item Обеспечивается подтверждение доставки
        \item Бывает однопоточным (протокол TCP) и многопоточным (протокол SCTP)
    \end{itemize}
\end{itemize}

\Subsection{Протокол UDP}

Used Datagram Protocol

По сравнению с другими транспортными протоколами имеет более высокую скорость и менее надёжен.

Зарезервирован номер 17 в IP-пакете. 

Для адресации используются UDP-порты.

Сервер {\it обычно} использует фиксированные номера портов.

Клиент {\it обычно} использует непривилегированные номера портов (обычно случайные).

Клиент должен знать, по какому порту стучаться на сервер, а сервер просто отвечает на тот же порт.

Весь обмен определяется двумя IP-адресами и двумя номерами портов.

\Subsubsection{Формат пакета UDP}

TODO: картинка

Длина сообщения~--- длина UDP дейтаграммы.

Контрольная сумма считается по всему пакету (а в IP только по заголовку).

Если контрольная сумма равна 0, то она не вычислялась (например, если мы верим, что у нас сверхнадёжный канал).

Контрольная сумма вычисляется с учётом псевдозаголовка.

TODO: картинка

Благодаря этому, если у нас была произведена атака и были подменены IP-адреса, а контрольную сумму злоумышленник не пересчитал, то она не сойдётся (скорее всего).

Поэтому злоумышленнику нужно сохранить к себе весь пакет и пересчитать контрольную сумму (ага, очень большая проблема для него).

Приложения, использующие UDP:
\begin{itemize}
    \item TFTP (69)
    \item DNS (53)
    \item SNMP (161, 162)~--- протокол управляющих сообщений
    \item BOOTP, DHCP (67, 68)~--- получение параметров IP
    \item RIP (520)~--- маршрутизация
\end{itemize}

\Subsection{Протокол TCP}

Transmission Control Protocol

По сравнению с UDP имеет:
\begin{itemize}
    \item Более низкую скорость
    \item Большую надёжность
\end{itemize}

Зарезервирован номер 6 в IP-пакете.

Адресация с помощью TCP-портов.

Передача~--- потоковая. Данные для передачи хранятся в буффере. Это единственный протокол, который имеет дело не с пакетами, а с двумя очередьми: буффером приёма и передачи. В отличие от UDP, оперируем сегментами, а не пакетами. Можем захотеть передать 100 байт, но они добавятся в общую очередь и за раз передастся 1000 байт.

Данные добавляются в конец буффера, а передаются из начала. 

Каждый передаваемый байт пронумерован. Сегменту присваивается номер его первого байта (номер очереди).

При посылке в сеть сегмента, он копируется в буффер повторной передачи, заводится таймаут. Если в течение таймаута не получили подтверждение, посылаем снова. И так делается (по дефолту) до 5 раз.

Каждый переданный байт должен быть подтверждён. При получения подтверждения от сегмента, подтверждёнными считаются все байты сегмента. Подтверждение содержит номер следующего ожидаемого байта.

TODO: картинка про простой.

В момент времени $T_1$ Алиса послала сообщение Бобу.

В момент времени $T_2$ Боб это сообщение получил и отправил подтверждение Алисе.

В момент времени $T_3$ Алиса получила подтверждение от Боба и может отправлять второй пакет. Таким образом, мы получили простой передачи $T_3-T_1$.

В TCP отрицательные квитанции не посылаются. Например, если у нас не сошлась контрольная сумма, нам не пошлют сообщение об ошибке. Принимающая сторона просто не будет посылать подтверждение получения и мы попробуем отправить пакет снова.

\Subsubsection{Формат TCP пакета}

TODO: картинка

\begin{itemize}
    \item Номер очереди~--- номер посланного сегмента при обмене или синхронизация номеров сегментов при установлении соединения
    \item Номер подтверждения~--- подтверждение принятого сегмента или синхронизация номеров сегментов при установлении соединения
    \item Смещение данных~--- длина заголовка TCP (и так же, как и в IP, с помощью него понимаем, есть у нас опции или нет)
    \item Окно~--- величина скользящего окна (о нём позже)
    \item Контрольная сумма~--- по всему высылаемому сегменту
    \item Указатель срочности~--- объём срочных данных

\end{itemize}

{\bf Флаги}

TODO: картинка

\begin{itemize}
    \item URG~--- флаг срочности. Задействовано поле <<Указатель срочности>>. Это позволяет передать определённый объём данных в сеть без буфферизации. Пример, когда надо: управление удалённым терминалом, компьютерные игры.
    \item ACK~--- флаг подтверждения. Задействовано поле <<Подтверждение>> и в этом пакете у нас находится квитанция.
    \item PSH~--- флаг проталкивания. Проталкивание буффера (на принимающей стороне). То есть мы там не будем ждать много времени, получая пакеты, а потом отправлять подтверждение сразу на все, а сразу протолкнём этот пакет и подтвердим его
    \item RST~--- флаг сброса. Перезагрузка соединения
    \item SYN~--- флаг синхронизации. Синхронизация номеров очередей для создания виртуального канала. Первый пакет с каждой стороны должен иметь установленным этот флаг
    \item FIN~--- флаг закрытия соединения. Завершение соединения
\end{itemize}

\Subsubsection{Установка соединения}

Хотим начать соединение. Нужно договориться, с какого номера клиент и сервер будут начинать отсчёт отправляемых сообщений. Казалось бы, можно начать с нуля (сначала даже так и делали), но выяснилось, что так хакерам проще вклиниться в уже установленное TCP соединение.

Поэтому решили номер первого сегмента генерировать случайно. 

Таким образом, вся установка соединения~--- двусторонний обмен номерами сегментов между отправляющей и принимающей сторонами.

\begin{enumerate}
    \item A посылает B пакет с флагом SYN, в котором указан номер первого сегмента минус единица ($N_{seqA}$)
    \item B посылает в ответ пакет с флагом ACK и $N_{ackB}=N_{seqA}+1$
    \item B посылает A пакет с флагом SYN и $N_{seqB}$
    \item A посылает B подтверждение о синхронизации с флагом ACK и $N_{ackA}=N_{seqB}+1$
\end{enumerate}

С этого момента каждый знает номер очереди собеседника и можно проводить штатный обмен.

{\bf НО!} в пакетах, отсылаемых в сообщениях 2 и 3 нет общих полей. Поэтому решили это передавать одним пакетом.

Это называется трёхпутевой схемой организации соединения.

\Subsubsection{Разрыв соединения}

\begin{enumerate}
    \item A посылает B пакет с флагом FIN
    \item B посылает A пакет с флагом ACK 
    \item B посылает A пакет с флагом FIN
    \item A посылает B пакет с флагом ACK
\end{enumerate}

\Subsubsection{Конечный автомат протокола TCP}

Как работает TCP:

\begin{itemize}
    \item На сервере есть сокет (допустим, на порту 80).
    \item Когда приходит запрос на соединение, пораждается ещё один сокет (с тем же номером порта)~--- рабочий. И именно с ним работает клиент. А прошлый сокет остался в состоянии слушания входящих соединений.
    \item У рабочего сокета может быть несколько состояний.
    \item Стоит заметить, что ничего страшного в том, что у рабочего сокета такой же номер порта нет, так как сокет определяется ещё и IP-адресом клиента.
\end{itemize}

TODO: картинка конечного автомата

На сервере решили организовать слущающий сокет. Сделали системный вызов listen. Сокет першёл в состояние LISTEN.

Если получили сигнал SYN, у нас породился второй сокет, красный продолжает слушать, а зелёный переходит в состояние SYN RCVD.

Получили ACK и перешли в состояние ESTABLISHED. В этом состоянии происходит вся передача данных. Все остальные состояния~--- служебные.

Пусть мы вызвали {\tt close}. Тогда перейдём в состояние FIN-WAIT1, получим ACK, перейдём в FIN-WAIT2, получим FIN, отправим ACK, перейдём в TIME-WAIT. Это долгое состояние, в котором мы разгребаем весь мусор из сети. Там ждём от полутора до трёх минут, собирая все приходящие данные, после чего переходим в CLOSED.

Есть утилита {\tt netstat}, которая позволяет посмотреть на сокеты и их состояния. Там скорее всего вы увидите толко LISTEN, ESTABLISHED и TIME-WAIT. Все остальные состояния очень быстрые.

Это было для сервера. А клиент посылает SYN, переодит в SYN SENT, ну а дальше всё так же.